# Bootcamp Online - Desenvolvedor Full Stack <!-- omit in toc -->

Link: <https://www.igti.com.br>

- [Módulo 01](#módulo-01)
  - [Aula 1 - Visual Studio Code](#aula-1---visual-studio-code)
  - [Aula 2 - Node.js](#aula-2---nodejs)
  - [Aula 3 - Noções de HTML](#aula-3---noções-de-html)
  - [Aula 4 - Noções de CSS](#aula-4---noções-de-css)
  - [Aula 5 - Introdução ao JavaScript](#aula-5---introdução-ao-javascript)
  - [Aula 6 - JavaScript - Comandos de Bloco](#aula-6---javascript---comandos-de-bloco)
  - [Aula 7 - JavaScript - Manipulação do DOM](#aula-7---javascript---manipulação-do-dom)
  - [Aula 8 - JavaScript - Formulários e Manipulação de Eventos](#aula-8---javascript---formulários-e-manipulação-de-eventos)
  - [Aula 9 - CRUD com HTML, CSS e JavaScript](#aula-9---crud-com-html-css-e-javascript)
  - [Trabalho Prático](#trabalho-prático)
  - [Aula 10 - JavaScript moderno - Introdução](#aula-10---javascript-moderno---introdução)
  - [Aula 11 - JavaScript moderno - Manipulação de arrays](#aula-11---javascript-moderno---manipulação-de-arrays)
  - [Aula 12 - JavaScript moderno - Rest/Spread operator e destructuring](#aula-12---javascript-moderno---restspread-operator-e-destructuring)
  - [Aula 13 - Refatoração do projeto de CRUD](#aula-13---refatoração-do-projeto-de-crud)
  - [Aula 14 - Introdução à programação assíncrona com JavaScript](#aula-14---introdução-à-programação-assíncrona-com-javascript)
  - [Aula 15 - Funções setTimeout e setInterval](#aula-15---funções-settimeout-e-setinterval)
  - [Aula 16 - Requisições HTTP com JavaScript](#aula-16---requisições-http-com-javascript)
  - [Aula 17 - Exercício guiado](#aula-17---exercício-guiado)
  - [Desafio do Módulo](#desafio-do-módulo)
- [Módulo 02](#módulo-02)
  - [Aula 1 - Backend, Frontend e API's](#aula-1---backend-frontend-e-apis)
    - [Backend](#backend)
    - [Frontend](#frontend)
    - [API (Application Programming Interface)](#api-application-programming-interface)
    - [Webservices](#webservices)
    - [REST (Representation State Transfer)](#rest-representation-state-transfer)
    - [URI (Uniform Resourcer Identifier)](#uri-uniform-resourcer-identifier)
  - [Aula 2 - NodeJS](#aula-2---nodejs-1)
  - [Aula 3 - Hello World Nodejs](#aula-3---hello-world-nodejs)
  - [Aula 4 - Node.js Event Loop](#aula-4---nodejs-event-loop)
  - [Aula 5 - Módulos do Node.js](#aula-5---módulos-do-nodejs)
  - [Aula 6 - Ferramentas para consumo de endpoints](#aula-6---ferramentas-para-consumo-de-endpoints)
  - [Trabalho Prático](#trabalho-prático-1)
  - [Aula 7 - ExpressJS: instalação e rotas](#aula-7---expressjs-instalação-e-rotas)
    - [Instalação](#instalação)
    - [Rotas do Express](#rotas-do-express)
  - [Aula 8 - Express: Middlewares, tratamento de erros e gravação de logs](#aula-8---express-middlewares-tratamento-de-erros-e-gravação-de-logs)
    - [Middlewares](#middlewares)
    - [Tratamento de erros](#tratamento-de-erros)
    - [Gravação de logs](#gravação-de-logs)
    - [Servindo arquivos estáticos](#servindo-arquivos-estáticos)
  - [Aula 9 - Apresentação da API e configurações iniciais](#aula-9---apresentação-da-api-e-configurações-iniciais)
  - [Aula 10 - Métodos POST e GET](#aula-10---métodos-post-e-get)
  - [Aula 11 - Métodos DELETE, PUT e PATCH](#aula-11---métodos-delete-put-e-patch)
  - [Aula 12 - Tratamento de erros, gravação de logs e validação de campos](#aula-12---tratamento-de-erros-gravação-de-logs-e-validação-de-campos)
  - [Aula 13 - Cors e Documentação](#aula-13---cors-e-documentação)
  - [Desafio do Módulo](#desafio-do-módulo-1)
- [Módulo 03](#módulo-03)
  - [Aula 01 - Ambiente de Desenvolvimento](#aula-01---ambiente-de-desenvolvimento)
  - [Aula 02 - Introdução ao React](#aula-02---introdução-ao-react)
  - [Aula 03 - Desafio Guiado 1](#aula-03---desafio-guiado-1)
  - [Aula 04 - Classes com JavaScript](#aula-04---classes-com-javascript)
  - [Aula 05 - Class Components – Parte 1](#aula-05---class-components--parte-1)
  - [Aula 06 - Class Components – Parte 2](#aula-06---class-components--parte-2)
  - [Aula 07 - Ciclo de vida de Class Components](#aula-07---ciclo-de-vida-de-class-components)
  - [Aula 08 - Desafio Guiado 2](#aula-08---desafio-guiado-2)
  - [Trabalho Prático](#trabalho-prático-2)
  - [Aula 09 - Functional Components](#aula-09---functional-components)
  - [Aula 10 - Desafio Guiado 3](#aula-10---desafio-guiado-3)
  - [Aula 11 - React Hooks](#aula-11---react-hooks)
    - [O Hook useState](#o-hook-usestate)
    - [O Hook useEffect](#o-hook-useeffect)
  - [Aula 12 - Desafio Guiado 4](#aula-12---desafio-guiado-4)
  - [Aula 13 - Desafio Guiado 4 (Continuação)](#aula-13---desafio-guiado-4-continuação)
  - [Desafio do Módulo](#desafio-do-módulo-2)
- [Módulo 04](#módulo-04)
  - [Aula 01 - MongoDB: Instalação, banco de dados e coleções](#aula-01---mongodb-instalação-banco-de-dados-e-coleções)
    - [Instalação no Windows](#instalação-no-windows)
    - [Principais Comandos](#principais-comandos)
  - [Aula 02 - MongoDB: Inserir Documentos (Create)](#aula-02---mongodb-inserir-documentos-create)
  - [Aula 03 - MongoDB: Consultar Documentos (Retrieve)](#aula-03---mongodb-consultar-documentos-retrieve)
  - [Aula 04 - CRUD no MongoDB (Update)](#aula-04---crud-no-mongodb-update)
  - [Aula 05 - MongoDB: Exclusão Documentos (Delete)](#aula-05---mongodb-exclusão-documentos-delete)
  - [Aula 06 - MongoDB: Comandos em Massa (BulkWrite)](#aula-06---mongodb-comandos-em-massa-bulkwrite)
  - [Aula 07 - MongoDB: índices, modelagens e agregações](#aula-07---mongodb-índices-modelagens-e-agregações)
  - [Aula 08 - MongoDB Atlas](#aula-08---mongodb-atlas)
  - [Aula 09 - Mongoose](#aula-09---mongoose)
  - [Aula 10 - API CRUD com Mongloose](#aula-10---api-crud-com-mongloose)
  - [Trabalho Prático](#trabalho-prático-3)
  - [Aula 11 - Git (Parte 1)](#aula-11---git-parte-1)
  - [Aula 12 - Git (Parte 2)](#aula-12---git-parte-2)
  - [Aula 13 - Heroku](#aula-13---heroku)
  - [Desafio do Módulo](#desafio-do-módulo-3)

## Módulo 01

### Aula 1 - Visual Studio Code

- Debugger for Chrome

- Prettier - Code formatter

- Live Server

### Aula 2 - Node.js

- npm install -g live-server

### Aula 3 - Noções de HTML

- Não é linguagem de progração e sim marcação, estrutura conteúdo.

- Escrevemos de forma declarativa, ou seja, escreve o que tem que ser feito e o navegador se vira pra renderizar.

- Utilize sempre caminhos relativos em imagens, arquivos e etc (./ ../).

### Aula 4 - Noções de CSS

- CSS Reset, geralmente os frameworks já estão configurados para isso, do contrário é recomendado fazer.

  - <https://meyerweb.com/eric/tools/css/reset>

### Aula 5 - Introdução ao JavaScript

- Tipos de dados:

  - Number: 1, -3, 8.56

  - String: "Teste", "3.14", 'Aspas Simples'

  - Boolean: true, false

  - Null: null (Explicitamente definido pelo programador)

  - Undefined: undefined (ausência de valor)

  - Object: (Tipo não primitivo) [1, 3, 5], [6, 'sete', true], {id: 2, nome: 'Raphael'}

  - Tipagem fraca

  - false, 0, null, undefined são tipos considerados _Falsy_, ou seja, tendem a ser falsos

  - true, 1, [1], {id: 1} são tipos considerados _Truthy_, ou seja, tendem a ser vedadeiros

  - Exemplo de igualdade:

    `2 === '2' = false; 2 == '2' = verdadeiro;`

### Aula 6 - JavaScript - Comandos de Bloco

- Operador Ternário:

  ```javascript
  var resposta = a > b ? 'Maior' : 'Menor';
  var resposta = a > b ? 'Maior' : a < b ? 'Menor' : 'Igual';
  ```

- Uma função pode retornar mais de um valor, porém é preciso retornar um objeto com chave valor. Caso contrário é 1 ou nada (void).

- Comparar valores:

  ```javascript
   function compareNumbers(a, b) {
     // return a > b ? 1 : a < b ? -1 : 0;
     retrun a - n;
   }
  ```

### Aula 7 - JavaScript - Manipulação do DOM

```javascript
var title = document.querySelector('h1'); // Se tiver mais de 1 elemento, só vai pegar 1
title.textContent = 'Mudar texto';

var peseronalDataArray = documento.querySelectorAll('.personal-data'); // Pega todos os elementos que tem a classe;
console.log(peseronalDataArray);
peseronalDataArray = Array.from(peseronalDataArray);
console.log(peseronalDataArray);

for (var i = 0; i < peseronalDataArray.length; i++) {
  var currentElement = peseronalDataArray[i];
  currentElement.classList.add('classe-css');
  currentElement.classList.remove('outra-classe-css');
}
```

### Aula 8 - JavaScript - Formulários e Manipulação de Eventos

- **eventPreventDefault:** "Evite o comportamento default", como por exemplo enviar para o servidor e ai manipular os dados.

### Aula 9 - CRUD com HTML, CSS e JavaScript

{ ... }

### Trabalho Prático

{ ... }

### Aula 10 - JavaScript moderno - Introdução

- **Template Literals**

  ```javascript
  let a = 3,
    b = 10,
    c = 7;
  let str = `Meus números são ${a}, ${b} e ${c}`;
  ```

- Boa prática usar _'use strict'_, no incio do arquivo em escopo de funções. Isso mostra mais erros caso ocorram e para a execução do script.

- **var** tem escopo abrangente e **let** tem o escopo reduzido.

- Uma variável do tipo **const** não é possível reatribuir valores. Com "certa" excessão de objetos e arrays, não é possível atribuir um novo objeto ou array, mas é pissível alterar os valores das propriedades do objeto ou dar push de um novo valor no array.

- Tipos de funções:

  ```javascript
  // Função comum do ECM5
  function sum(a, b) {
    return a + b;
  }

  // Função anônima
  const sum2 = function (a, b) {
    retrun a + b;
  }

  // Arrow function
  const sum3 = (a, b) {
    return a + b;
  }

  // Arrow function reduzida (apenas uma instrução)
  const sum3 = (a, b) => a + b;

  // Default parameters
  // (Não pode no primeiro, pois quando se chama a função, o primeiro parâmetro é sempre obrigatório)
  const sum4(a, b = 10) => a + b;
  ```

### Aula 11 - JavaScript moderno - Manipulação de arrays

Com excessão do _sort()_ (a princípio), todos são métodos **imutáveis**, ou seja, não altera o objeto original, é criado um novo.

Em métodos não mutáveis, não é preciso retorar ao objeto igualando-o a outro ou a ele mesmo, pois o método altera a estrutura orinal. Por exemplo:

```javascript
// Altera a estrutura original.
allCountries.sort((a, b) => {
  return a.name.localeCompare(b.name);
});

// Filter é imutável, por isso é preciso retornar a um novo objeto.
favoriteCountries = favoriteCountries.filter((country) => country.id !== id);
```

- **map:** Gera um novo array transformando os dados.

  ```javascript
  // Retornar um novo objeto
  const nomeEmailArray = people.results.map((person) => {
    return {
      nome: person.name,
      email: person.email,
    };
  });
  ```

- **filter:** gera um novo array filtrando elementos com base em proposição (if/else).

  ```javascript
  const olderThan50 = people.results.filter((person) => {
    return person.dob.age > 50;
  });
  ```

- **forEach:** percorre todos os elementos do array, aplicando lógica.

  ```javascript
  // Incluir nova propriedade no objeto
  const mappedPeople.forEach(person => {
    person.nameSize =
      person.name.title.length +
      person.name.first.length +
      person.name.last.length;
  });
  ```

- **reduce:** realiza cáculo interativo com base nos elementos.

  ```javascript
  // Somar as idades de todos (substitui for, por exemplo)
  const totalAges = people.results.reduce((accumulator, current) => {
    return accumulator + current.dob.age;
  }, 0);
  ```

- **find:** encontra elementos com base em proposições (if/else).

  ```javascript
  // Encontrar primeira ocorrência
  const found = people.results.find((person) => {
    return person.location.state === 'Minas Gerais';
  });
  ```

- **some:** verifica se há pelo menos um elemento que atenda à proposição retornando true/false (if/else) ou predicado.

  ```javascript
  // Se encontrou algo de acordo com o critério | true/false
  const found = people.results.some((person) => {
    return person.location.state === 'Amazonas';
  });
  ```

- **every:** verifica se todos os elementos atendem à proposição, retornando true/false (if/else).

  ```javascript
  // Se todos form iguais ao critério
  const every = people.results.every((person) => {
    return person.nat === 'BR';
  });
  ```

- **sort:** ordena elementos com base em critérios.

  ```javascript
  // startsWith: função padrão do JS
  const mappedNames = people.results
  .map(person => {
    // return person.name.first; // Retorna Array de strings
    return {
      name: person.name.first; // Retorna Array de strings
    };
  })
  .filter(person => person.name.startsWith('A'))
  .sort((a, b) => {
    return a.name.localeCompare(b.name); // return -1, 0, 1
    // return a.name.length - b.name.length; // return -1, 0, 1
  });
  // .sort(); // Se for puramente string ou tipos numéricos (int, float) funciona tranquilo (talvez)
  ```

### Aula 12 - JavaScript moderno - Rest/Spread operator e destructuring

- Operador **...(spread)** ou espalhar. Em arrays, ele espalha os itens do array, que podem ser recuperados para compor outro array.

  ```javascript
  // Concatenar dois objetos
  const marriedMen = people.results.filter(
    (person) => person.name.title === 'Mr'
  );

  const marriedWomen = people.results.filter(
    (person) => person.name.title === 'Ms'
  );

  const marriedPeople = [...marriedMen, ...marriedWomen, { msg: 'Oi' }];
  console.log('marriedPeople', marriedPeople);
  ```

- Operador **...(rest)** ou agrupar. Comum na utilização em funções, agrupando os parâmetros em um array. Sendo sua principal aplicação permitir funções com número infinito de parâmetros.

  ```javascript
  function infiniteSum(...numbers) {
    return numbers.reduce((acc, curr) => acc + curr, 0);
  }

  console.log(infiniteSum(1, 2));
  console.log(infiniteSum(1, 2, 3, 4, 5, 6, 20, 30, 50));
  ```

- **Destructuring**. Facilita a escrita ao trabalhar com objetos, torna o código claro e também é possível utilizar a técnica de destructuring com arrays, usando [].

  ```javascript
  const first = people.results[0];

  // Isso é repetitivo
  const username = first.login.username;
  const password = first.login.password;

  // Usando Destructuring
  const { username, password } = first.login;

  console.log('username', username);
  console.log('password', password);
  ```

### Aula 13 - Refatoração do projeto de CRUD

- Dica: Numa função que precise passar 2 parâmetros, mas só é precisar utilizar o segundo, usasse como boa prática o "**\_**" como primeiro parâmetro. Ex:

  ```javascript
  globalNames = globalNames.filter((_, i) => i !== index);
  ```

### Aula 14 - Introdução à programação assíncrona com JavaScript

- Operações. Ex:

  - Requisão de APIs.

  - Processamento intenso de dados.

  - Comunicação com bancos de dados.

- É extremamente importante que o javascript **não espere o término de instruções lentas**.

- A principal técnica para grantir a afirmação acima é a utilização de **event loop**.

  - Funções a serem executadas ficam em uma pilha lógica de invocações (call stack).

  - Quando a função utiliza Web APIs, ela precisa passar pelo event loop, pois está sujeita a lentidões.

  - O **event loop** executa uma função por vez e faz a orquestração que permite execução assíncrona.

  - Em geral, funções que usam WEB APIs possuem **callbacks** (funções passadas por parâmetro).

  - <https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5>

### Aula 15 - Funções setTimeout e setInterval

- setTimeout(): É utilizada para postergar a execução de uma função e o tempo de atraso é configurável em milissegundos.

- setInterval(): É semelhante ao setTimeout(), mas repete a execução a cada X milissegundos. Pode ser cancelada com **clarInterval**, mas para isso é preciso guardar a referência em uma varável.

  ```javascript
  const timer = document.querySelector('#timer');
  let count = 0;

  const interval = setInterval(() => {
    timer.textContent = ++count;

    if (count === 10) {
      this.clearInterval(interval);
      return;
    }

    if (count % 5 === 0) {
      setTimeout(() => {
        timer.textContent = `${count},5`;
      }, 500);
    }
  }, 1000);
  ```

### Aula 16 - Requisições HTTP com JavaScript

- Comando **Fetch**.

  - Utilizado para requisições HTTP.

  - Trabalha internamente com promises.

  - O primeiro retorno do fetch são dados binários.

  - Em geral, convertemos esses dados para JSON, que retorna outra promise.

  - Vale a leitura sobre a bibliota **axios**.

  ```javascript
  const userGitHub = fetch('https://api.github.com/users/cjambrosi');
  console.log('promise:', userGitHub);

  // catch: captura quando da problema
  // then: captura deu certo
  fetch('https://api.github.com/users/cjambrosi').then((resource) => {
    console.log('Promise resolvida');
    console.log('resource', resource);
    resource.json().then((data) => {
      console.log('data', data);
      showData(data);
    });
  });

  console.log('Depois resolvida');

  const showData = (data) => {
    const user = document.querySelector('#user');
    console.log(`${data.login} - ${data.name}`);
    user.textContent = `${data.login} - ${data.name}`;
  };
  ```

- **Promises**.

  - São construções cuja a execução **retorna algo no futuro**, ou seja, é uma **promessa de execução**.

  - A execução pode ser **resolvida (ok)**, ou **rejeitada (erro)**.

  - A promise resolvida é interceptada com **then**.

  - A promise rejeitada é interceptada com **catch**.

  - Resolve parcialmente o problema do **callback heel**, ou seja, funções que eram passadas por parâmetros de outras funções (triângulo lateral).

  ```javascript
  fetch('https://api.github.com/users/cjambrosi')
    .then((resource) => {
      resource.json().then((data) => {
        console.log('data', data);
        showData(data);
      });
    })
    .catch((error) => {
      console.error('Erro na requisição');
    });

  // Exemplo criação de Promise
  const divisionPromise = (a, b) => {
    return new Promise((resolve, reject) => {
      if (b === 0) {
        reject('Não é possível dividr por 0');
      }

      resolve(a / b);
    });
  };

  divisionPromise(10, 2).then((result) => {
    console.log('result', result);
  });
  divisionPromise(10, 0)
    .then((result) => {
      console.log('result', result);
    })
    .catch((errorMessage) => {
      console.log(`Falha na divisão ${errorMessage}`);
    });
  ```

- **Async/Await**.

  - Açúcar sintático (syntax sugar) sobre promises.

  - Melhoram a **legibilidade** do código.

  - Dá a impressão de código síncrono.

  - Deve-se decorar a função com **async**.

  - Toda intrução relacionada à promise deve ser precedida de **await**.

  ```javascript
  // Exemplo criação de Promise
  const divisionPromise = (a, b) => {
    return new Promise((resolve, reject) => {
      if (b === 0) {
        reject('Não é possível dividr por 0');
      }

      resolve(a / b);
    });
  };

  // Isso é muito confuso
  const executeDivisionPromise = () => {
    divisionPromise(10, 0)
      .then((result) => {
        console.log('result', result);
      })
      .catch((errorMessage) => {
        console.log(`Falha na divisão ${errorMessage}`);
      });
  };
  executeDivisionPromise();

  const executeDivisionPromiseAsyncAwait = async () => {
    const division = await divisionPromise(10, 2);
    console.log('divisionAsync', division);

    const division2 = await divisionPromise(10, 0);
    console.log('divisionAsync2', division2);
  };
  executeDivisionPromiseAsyncAwait();

  // Exemplo de Async com Fetch
  const doFetchAsync = async () => {
    const res = await fetch('https://api.github.com/users/cjambrosi');
    const json = await res.json();
    console.log('json', json);
  };
  doFetchAsync();
  ```

### Aula 17 - Exercício guiado

{ ... }

### Desafio do Módulo

{ ... }

## Módulo 02

### Aula 1 - Backend, Frontend e API's

#### Backend

Se refere a parte que fica hospedada no servidor, focando principalmente em como a aplicação funciona. Responsável por interagir com o banco de dados, granvando e buscando registros. Importane para armazenar as regras de negócio da aplicação.

Exemplos de linguagens:

- Java
- C#
- PHP
- JavaScript (NodeJS)

#### Frontend

Parte da aplicação com a qual o usuário interege. As páginas podem ser montadas no servidor e devolvidas prontas para o usuário ou montadas no próprio browser do usuário. (Server Side Rendering e Cliente Side Rendering).

- HTML
- CSS
- JavaScript

#### API (Application Programming Interface)

Conjunto de serviços que são expostos de forma a permitir a comunicação entre sistemas. Uma aplicação acessa recursos da outra sem saber como foram implementados (quem está fornecendo tem um maior controle sobre o que está sendo feito). Pode ser vista como um contrato, representado pela documentação.

#### Webservices

Serviços que fazem parte de uma API. Um Webservice somente transmite as informações, não sendo por si só uma aplicação possível de ser acessada pela web. Muitas empresas estão criando APIs de suas aplicações, de forma a possibilitar a fácil integração de outras aplicações.

Algumas características

- Facilidade na integração de sistemas: Depende do protocolo HTTP e um formato, com o JSON.
- Favorece a reutilização de software: Integração entre aplicações desenvolvidas em liguagens e plataformas diferentes.
- Segurança na integração: Evita que aplicações integrem diretamente pelo banco de dados.

#### REST (Representation State Transfer)

Descrito por Roy Fielding, um dos criadores do protocolo HTTP. Utiliza uma URI para realizar uma chamada de serviço.
Geralmente aplicações web que trabalham com REST utilizam o formato JSON.

#### URI (Uniform Resourcer Identifier)

URIs são interfaces de utilização do serviço, servindo como um contrato, exemplo: <http://www.teste.com.br/clientes/2>.
As URIs que uma API disponibiliza também são conhecidadas como seus **endpoints**.

Através dos endpoints é possível realizar várias operações. Além do endpoint, o cliente precisa informar o método HTTP:

- GET: Obter os dados de um recurso.
- POST: Criar um novo recurso.
- PUT: Substituir os dados de um determinado recurso.
- DELETE: Excluir um determinado recurso.

### Aula 2 - NodeJS

Foi criado em 2009 na tentativa de resolver o problema de arquiteturas bloqueantes. Plataformas como .NET, Java, ou PHP paralisam um processamento enquanto realizam um processo de I/O no servidor. Esta paralização é o chamado modelo bloqueante (Blocknig-Thread).

Enquanto uma requisição é processada, as demais ficam ociosas em espera. Esses servidores criam várias threads para darem vazão a fila de espera, pode ser necessário fazer upgrade dos hardwares.

O NodeJS possui uma arquitetura não bloqueante (non-blocking-thread). Apresentando uma boa performance em consumo de memória e utilizando ao máximo o poder de processamento dos servidores. Nele as aplicações são single-thread, ou seja, cada aplicação possui um único processo. Utiliza bastante a programação assíncrona, com o auxílio das funções callback do JavaScript.

Em uma arquitetura bloqueane, o jeito de lidar com essa concorrência seria criar múltiplas threads para lidar com as diversas requsições.

O NodeJS foi criado utilizando o V8, que é um motor JavaScript de código aberto, criado pela Google e utilizado no Google Chrome. Com ele é possível executar código JavaScript no servidor, mantendo um serviço rodando no servidor, que faz a interpretação e execução de códigos JavaScript.

A criação do NodeJS está muito ligada com a crescente utilização das SPAs. Também é possível criar aplicações desktop, com o auxílio de ferramentas como o Electron por exemplo. Pode ser utilizado em aplicações Real-Time, como aplicações colaborativas, por exemplo: Aplicativos de mensagens e jogos online.

O NodeJS não é muito recomendado para aplicações que lidam com algoritmos complexo e que consumam muita CPU. Esta limitação pode ser contornada com a utilização de **Workers** (Instaciar o NodeJS (V8) para um algoritmo específico, por exemplo).

### Aula 3 - Hello World Nodejs

Iniciar projeto em NodeJS

> npm install

Iniciar projeto em NodeJS aceitando todas as opções como _default_.

> npm install -y

```javascript
console.log(process.argv); // Fornecido pelo Node (Array)
```

### Aula 4 - Node.js Event Loop

O NodeJS é uma plataforma baseada em eventos. Isso significa tudo que acontece no NodeJS é uma reação a um evento. Seguindo a mesma filosofia de orientação de eventos do JavaScript. Uma transação processada passa por várias callbacks.

O NodeJS trabalhar dessa forma porque as operações de I/O e de rede são muito lentas.

Graças ao **Event Loop** o NodeJS trabalha com assincronismo, permitindo que seja desenvolvido uma aplicação orientada a eventos, graças ao Event Loop. O **Event Loop** basicamente é um loop infinito, que a cada iteração verifica se exitem novos eventos em sua fila de eventos.

O módulo responsável por emitir eventos é o EventEmitter. Quando um evento é emitido, ele é enviado para a fila de eventos, para que o Event Loop possa executá-lo e depois retornar seu callback.

O Event Loop possui uma _stack_, e sempre que um método é chamado ele entra na _stack_ para aguardar seu processamento.

Quando são executadas ações de I/O que demandaram tempo, o NodeJS envia essas operações para outra thread do sistema. Após outra thread dos sistema executar a tarefa I/O, ele envia essa tarefa para a Task Queue.

Na Task Queue há dois tipos de tasks, as _micro tasks_ e as _macro tasks_. Somente as _macro tasks_ devem ser processadas em um ciclo do Event Loop. As _micro taskas_ são tarefas que devem ser executadas rapidamente após alguma ação.

Após o Event Loop processar uma _macro task_ da Task Queue, ele deve processar todas as _micro tasks_ disponíveis antes de chamar outra _macro task_.

### Aula 5 - Módulos do Node.js

Módulos do NodeJS é o mesmo que uma biblioteca no JavaScript, é um conjunto de funções que podem ser incluídas em uma aplicação. O NodeJS segue o **CommonJS**, uma especificação de ecossistemas para JavaScript.

Porém, recentemente passou a oferecer suporte ao ES Modules (no momento, ainda experimental), padrão atual para exportação/importação de módulos. Assim é possível incluir um módulo que está em outro arquivo, sendo possível criar um módulo e importa-lo em outro arquivo facilmente.

- CommonJS: require
- ES Modules: import
- Exemplos de módulos nativos:
  - File System
  - Readline
  - Eventes
  - HTTP

Para utilizar o padrão ES Modules é preciso alterar a extensão do arquivo de **.js** para **.mjs** ou no arquivo **package.json** do projeto NodeJS, alterar/incluir o **type** para **module**.

```json
"type": "module"
```

Nas versões 12.18 do NodeJS para trás, é preciso rodar o _index.js_ com a seguinte flag:

> node index.js --experimental-modules

Exemplos de importação/exportação com o CommonJS:

```javascript
// File: operacoes.js

const nome = 'Teste Exportação';

function soma(a, b) {
  return a + b;
}

function subtracao(a, b) {
  return a - b;
}

module.exports = { soma, subtracao, nome }; // Exportação default, exportando um objeto.
```

```javascript
// File: operacoes2.js

function multiplicacao(a, b) {
  return a * b;
}

module.exports = multiplicacao;
```

```javascript
// File: index.js

const op = require('./operacoes.js');
const op2 = require('./operacoes2.js');

op.nome;
op.soma(2, 3);
op.subtracao(5, 3);
op2.multiplicacao(3, 4);
```

Exemplos de importação/exportação com o ES Modules:

```javascript
// File: operacoes.js

const nome = 'Teste Exportação';

function soma(a, b) {
  return a + b;
}

function subtracao(a, b) {
  return a - b;
}

export default { soma, subtracao, nome };
```

```javascript
// File: operacoes2.js

function multiplicacao(a, b) {
  return a * b;
}

export default multiplicacao;
```

```javascript
// File: exportacoesNomeadas.js

export function divisao(a, b) {
  // Tipo de exportação chamada de Exportação Nomeada.
  return a / b;
}

export function resto(a, b) {
  // Tipo de exportação chamada de Exportação Nomeada.
  return a % b;
}
```

```javascript
// File: index.js

import op from './operacoes.js';
import op2 from './operacoes2.js';

// Maneira de importar uma Exportação Nomeada.
import { divisao, resto } from './exportacoesNomeadas.js'; // Obriga usar o mesmo nome declarado no arquivo.

op.nome;
op.soma(2, 3);
op.subtracao(5, 3);
op2.multiplicacao(3, 4);

divisao(10, 2);
resto(7, 2);
```

Módulo Default - File System

```javascript
import fs from 'fs';

// Exemplo de Event Loop

// Esvrever em um arquivo
fs.writeFile('teste.txt', 'bla bla bla', function (err) {
  if (err) {
    console.log(err);
  } else {
    console.log('Arquivo escrito com sucesso!');

    // Adiciona conteúdo no final do arquivo
    fs.appendFile('teste.txt', '\nteste apeend file', function (err) {
      if (err) {
        console.log(err);
      }
    });

    // Ler um arquivo
    fs.readFile('teste.txt', 'utf-8', (err, data) => {
      if (err) {
        console.log(err);
      } else {
        console.log(data);
      }
    });
  }
});
```

- Lendo arquivo de forma Síncrona

  ```javascript
  import fs from 'fs';

  trye {
    console.log('1');
    fs.writeFileSync('teste.txt', 'bla bla bla');
    console.log('2');
    const data = fs.readFileSync('teste.txt', 'utf-8');
    console.log(data);
    console.log('3');
  } catch(err) {
    console.log(err);
  }
  ```

- Importar módulo em formato de Promises

  ```javascript
  import { promises as fs } from 'fs';

  // Maneira Ruim para ler um arquivo
  fs.writeFile('teste.txt', 'bla bla bla')
    .then(() => {
      fs.appendFile('teste.txt', '\nteste append file')
        .then(() => {
          fs.readFile('teste.txt', 'utf-8')
            .then((resp) => {
              console.log(resp);
            })
            .catch((err) => {
              console.log(err);
            });
        })
        .catch((err) => {
          console.log(err);
        });
    })
    .catch((err) => {
      console.log(err);
    });

  // Melhor maneira para ler um arquivo (asybc/await)
  async function init() {
    try {
      await fs.writeFile('teste.txt', 'bla bla bla');
      await fs.appendFile('teste.txt', '\nteste append file');
      const data = await fs.readFile('teste.txt', 'utf-8');
      console.log(data);
    } catch (err) {
      console.log(err);
    }
  }
  ```

Módulo Default - File System JSON

```javascript
import { promises as fs } from 'fs';

//  JSON.stringify
async function writeJson() {
  try {
    // Valores iniciais
    const arrayCarros = ['Palio', 'Gol', 'Uno'];
    const obj = { carros: arrayCarros };

    // Leitura do conteúdo atual do objeto
    await fs.writeFile('teste.json', JSON.stringify(obj));
    const data = JSON.parse(await fs.readFile('teste.json'));

    // Modificado conteúdo objeto
    data.carros.push('Sandero');

    // Sobrescrito conteúdo do objeto
    await fs.writeFile('teste.json', JSON.stringify(data));
  } catch (err) {
    console.log(err);
  }
}
```

Módulo Default - Read Line

- Permite entradas do usuário (terminal, por exemplo).

```javascript
import readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

rl.question('Digite um Número: ', (numero) => {
  console.log(numero);
  rl.close(); // Se quiser encerrar o programa
});

function pergunta() {
  rl.question('Digite um Número: ', (numero) => {
    if (parseInt(numero) === -1) {
      rl.close();
    } else {
      const multiplos = [];
      for (let i = 3; i < parseInt(numero); i++) {
        if (i % 3 === 0 || i % 5 === 0) {
          multplos.push(i);
        }
      }

      console.log(multiplos);
      pergunta();
    }
  });
}
```

Módulo Default - Events

```javascript
// events.js

import { EventEmitter } from 'events';

const eventEmitter = new EventEmitter();

eventEmitter.on('testEvent', (obj) => {
  console.log(obj);
});

export default eventEmitter;
```

```javascript
// index.js

import ev from './events.js';

eventEmitter.on('testEvent', () => {
  console.log('Ouviu tbm!');
});

ev.emit('testEvent', 'bla bla bla');
```

Módulo Default - HTTP

> npm install nodemon -g

> nodemon index.js

```javascript
import http from 'http';

http
  .createServer((req, res) => {
    if (req.method === 'GET' && req.url === '/teste') {
      res.write('GET /teste executado com sucesso!'); // Responde na tela para o usuário
    } else {
      res.write('Hello Word');
    }

    res.statusCode = 200;
    res.end();
  })
  .listen(8080);
```

### Aula 6 - Ferramentas para consumo de endpoints

Insomnia: <https://insomnia.rest/>

Postman: <https://www.postman.com/>

### Trabalho Prático

{ ... }

### Aula 7 - ExpressJS: instalação e rotas

O ExpressJS é um framework web para NodeJS. Com ele o desenvolvimento de aplicações é mais rápido e fácil em comparação ao desenvolvimento somente utilizando o NodeJS. Se autodescreve como um framework web rápido, flexível e minimalista para NodeJS.

Facilita o roteamento (se refere a como os endpoints respondem as solicitações) da aplicação, baseado nos métodos HTTP e URLs.

#### Instalação

Criar projeto Node.

> npm install -y

Instalar o pacote do ExpressJS.

> npm install express

Para não ter que "restartar" toda a vez o servidor, instale o Nodemon.

> npm install -g nodemon

- Para executar:

  > nodemon index.js

Exemplo de utilização do ExpressJS:

```javascript
// index.js

impot express from 'express';

const app = express();

app.post('/', (req, res) => {
  const a = 3;
  const a = 5;
  res.send('Resultado: ' + soma(a, b));
})

function soma(a, b) {
  const resultado = a + b;
  return resultado;
}

app.get('/', (req, res) => {
  res.send('GET | Hello World!');
});

app.listen(3000, () => {
  console.log('API Started!');
});
```


https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API/Using_Fetch


Tutor Marco Ramos 07:46 PM 
Oi Pedro.
Abra o prompt de comando como administrador e digite:
netstat -a -b
aí voce vai ter o nome do processo que está utilizando tal porta e você pode finalizá-lo pelo Gerenciador de Tarefas.


https://restfulapi.net/http-methods/

Tutor Odivaney Ramos 08:07 PM 
Eu me equivoquei Denner, o ideal é fazer algo paliativo como vc fez realmente.
Tutor Odivaney Ramos 08:08 PM 
https://www.it-swarm.dev/pt/node.js/como-enviar-numeros-inteiros-nos-parametros-de-consulta-no-servico-nodejs-express/1042501448/

#### Rotas do Express

Caracteres especiais na rota:

```javascript
// index.js

import express from 'express';

const app = express();

// Pega todos os tipos de requisições do método HTTP e retorna a mesma callback
app.all('/testeAll', (req, res) => {
  res.send(req.method);
});

// Ultimo caracter é opcional, exemplo: test
app.get('/teste?', (_, res) => {
  res.send('/teste?');
});

// Ultimo caracter pode repetir várias vezes, ex: testeeeee
app.get('/teste+', (_, res) => {
  res.send('/teste+');
});

// Pode inserir qualquer coisa depois do "one", que ele cairá na rota "one"
app.get('/one*blue', (_, res) => {
  res.send(req.path);
});

// Tudo dentro do () é tratado como unidade
app.post('/test(ing)?', (_, res) => {
  res.send('/test(ing)?');
});

// Utilizar expressões regulares. No caso, qualquer string contenhar a palavra "red"
app.get(/.*red$/, (_, res) => {
  res.send('/.*red$/');
});

app.list(3000, () => {
  console.log('API Started');
});
```

Parâmetros na rota:

```javascript
// index.js

import express from 'express';

const app = express();

// É preciso avisar ao Express que queremos utilizar JSON no envio do Boddy
app.use(express.json());

app.get('testParam/:id', (req, res) => {
  res.send(req.params.id);
});

app.get('testParam/:id/:a?', (req, res) => {
  res.send(req.params.id + ' ' + req.params.a);
});

// Parâmetro NEXT, serve para passar para a próxima função callback
app.get(
  'testMultipleHandlers',
  (req, res, next) => {
    console.log('Callback 1');
    next();
  },
  (req, res) => {
    console.log('Callback 2');
    // É preciso fechar a requisição
    res.end(); // Se não tem resposta
    res.send('bla bla'); // Se tem resposta
  }
);

// Com Array
const callback1 = (req, res) => {
  console.log('Callback1');
  nex();
};

function callback2(req, res) {
  console.log('Callback2');
  nex();
}

const callback3 = (req, res) => {
  console.log('Callback3');
  res.end();
};

app.get('/testMultiplesHandlersArray', [callback1, callback2, callback3]);

app.list(3000, () => {
  console.log('API Started');
});
```

Parâmetros via Query na rota: É feito a partir de um ponto de interrogação, assim ele não faz parte da rota obrigatório. Sendo possível capturar em formato JSON. Ex:

`http://localhost:3000/testQuery?nome=joao&email=joao@gmail.com&...`

```javascript
// index.js

import express from 'express';

const app = express();

// É preciso avisar ao Express que queremos utilizar JSON no envio do Boddy
app.use(express.json());

app.get('testQuery', (req, res) => {
  res.send(req.query);
});

app.list(3000, () => {
  console.log('API Started');
});
```

Route do ExpressJS: Rotas que irão responder no mesmo endereço, mudando somente o tipo/verbo do método HTTP, podem ser agrupadas numa mesma rota. Devem ser definidas.

```javascript
// index.js

import express from 'express';

const app = express();

// É preciso avisar ao Express que queremos utilizar JSON no envio do Boddy
app.use(express.json());

app
  .route('/testRoute')
  .get((req, res) => {
    res.send('/testRoute GET');
  })
  .post((req, res) => {
    res.send('/testRoute POST');
  })
  .delete((req, res) => {
    res.send('/testRoute DELETE');
  });
// Poderia definir o método PUT, não é obrigatório, é possível definir só o que precisa

app.list(3000, () => {
  console.log('API Started');
});
```

### Aula 8 - Express: Middlewares, tratamento de erros e gravação de logs

#### Middlewares

Funções middlewares são funções que tem acesso ao seguinte:

- Objeto de solicitação (req).
- Objeto de resposta (res).
- Próxima função de middleware no ciclo de requisição e resposta do aplicativo (next).

Podem executar qualquer código, fazer mudanças nos objetos de solicitação, encerrar o ciclo e chamar a próxima função de middleware na pilha. Pode se uilizado para interceptar chamadas em específico ou qualquer chamada. São as funções que são executadas quando determinada rota é atingida.

É possível criar middlewares a nível de aplicação e a nível do roteador. Rotas no nível de roteador, é possível agrupar requisições e coloca-las em outro arquivo.

Nível de Aplicação:

```javascript
// index.js

import express from 'express';

const app = express();
app.use(express.json());

// Forma de executar um código, independente da requisição.
app.use((req, res) => {
  console.log(new Date());
  next();
});

app.get((req, res) => {
  res.send();
});

app.list(3000, () => {
  console.log('API Started');
});
```

Nível de Roteador:

```javascript
// carrosRouter.js

import express from 'express';

const router = express.Router();
// router.use(express.json());

router.get('/', (req, res) => {
  console.log('GET /carros');
  res.send('GET /carros');
});

router.get('/precos', (req, res) => {
  console.log('GET /carros/precos');
  res.send('GET /carros/precos');
});

export default router;
```

```javascript
// index.js

import express from 'express';
import carrosRouter from './carrosRouter.js';

const app = express();
app.use(express.json());

app.use('/carros', carrosRouter);

app.list(3000, () => {
  console.log('API Started');
});
```

#### Tratamento de erros

Tratamento de erros é uma parte muito importante de uma API, pois um erro pode ser originário de vários pontos. É importante que a API seja capaz de se recuperar de um erro e informar adequadamente ao usuário o que ocorreu. O Express faz um tratamento padrão caso nenhum outro tenha sido especificado.

Caso o erro tenha sido gerado a partir de um código assíncrono e deseja utilizar o tratamento padrão, é preciso passar o erro para o "next".

O Express permite que o desenvolvedor escreve as próprias funções para tratamento de erro, basta adicionar um quarto parâmetro na função de middleware.

O middleware para tratamento de excessões deve ser configurado por ultimo na instância do Express, assim ele receberá erros gerados em todas as definições anteriores.

É permitido que exista várias funções de tratamento de erros. Basta chama o "next" passando o objeto de erro como parâmetro, para envia o fluxo para próxima função. Neste caso a última função de tratamento deverá encerrar a requisição através do objeto de resposta.

```javascript
// index.js

import express from 'express';

const app = express();
app.use(express.json());

app.get('/', (req, res) => {
  throw new Error('Error message test'); // Forçando um erro
});

// Em funções assincronas, se ocorrer um erro é preciso passar ele para o "next"
// se não a requisição entra em looping, pois não há retorno
// Sempre colocar o código em uma estrutura Try Catch
app.post('/', async (req, res, next) => {
  try {
    throw new Error('Error message async');
  } catch (err) {
    next(err);
  }
});

// Interessante usar ela final, se for utilizar em todas as funções a cima dela.
app.use((err, req, res, next) => {
  console.log('Erro 1');
  next(err); // É preciso enviar o erro para a proxima função, se houver uma próxima
});

app.use((err, req, res, next) => {
  console.log('Erro 2');
  res.status(500).send('Ocorreu um erro, tente novamente mais tarde.');
});

app.list(3000, () => {
  console.log('API Started');
});
```

#### Gravação de logs

Uma funcionalidade muito importante para uma API é a gravação de logs. Métodos do console nativo do JavaScript, como console.log, console.error, e console.warn, não é possível desativas seus logs, nem definir o nível de logs e são funções síncronas.

Existem várias bibliotecas de log para o Node que tentam oferecer uma solução de log mais completa. Como por exemplo a **Winston**. Que é uma biblioteca que permite vários tipos de transporte (por exemplo, gravar em uma Banco de Dados), permite a configuração de formatos de log, até 7 níveis, que são:
**error: 0**, **warn: 1**, **info: 2**, **http: 3**, **verbose: 4**, **debug: 5**, **silly: 6**.

Para instalar a biblioteca **Winston**:

> npm intall winston

```javascript
// index.js

import express from 'express';
import winston from 'winston';

const app = express();
app.use(express.json());

const { combine, printf, label, timestamp } = winston.format;

const myFormat = printf({
  (level, message, label, timestamp) => {
    return `${timestamp} [${label}] ${level}: ${message}`;
  }
});

// Configurações do Winston
const logger = winston.createLogger({
  level: 'silly', // Definir o nível para imprimir
  transports: [
    new winston.transports.Console(), // Ir para o console
    new winston.transports.File((filename: 'my-log.log')), // Ir para um arquivo
  ],
  format: combine(
    label({ label: 'my-app'}),
    timestamp(),
    myFormat
  )
});

logger.error('Error log');
logger.warn('Warn log');
logger.info('Info log');
logger.verbose('Verbose log');
logger.debug('Debug log');
logger.silly('Silly log');

logger.log('info', 'Hello with parameter!');

app.list(3000, () => {
  console.log('API Started');
});
```

#### Servindo arquivos estáticos

Uma funcionalidade interessante do Express é que ele permite que sejam servidos arquivos estáticos.

O **express.static**, que recebe como parâmetro o diretório raiz de onde estão localizados os arquivos partindo da raiz da aplicação (documentação da aplicação ou arquivo pro front-end). Pode-se utilizar estes métodos várias vezes para servir vários diretórios. Também, pode-se criar um diretório virtual, passando como parâmetro o nome desejado.

```javascript
// index.js

import express from 'express';

const app = express();
app.use(express.json());

// Caminho do diretório que poderá ser acessado
// No caso, diretório que contém imagens
app.use(express.static('public'));

// É possível definir que uma rota seja acessar por uma caminho virtual
app.use('/images', express.static('public'));

app.list(3000, () => {
  console.log('API Started');
});
```

### Aula 9 - Apresentação da API e configurações iniciais

{ ... }

### Aula 10 - Métodos POST e GET

{ ... }

### Aula 11 - Métodos DELETE, PUT e PATCH

{ ... }

### Aula 12 - Tratamento de erros, gravação de logs e validação de campos

{ ... }

### Aula 13 - Cors e Documentação

Links úteis:

- [Swagger Editor](https://editor.swagger.io)
- [Swagger UI Express](https://www.npmjs.com/package/swagger-ui-express)
  - Para acessar a documentação criada: <http://localhost:3000/doc>
- [Cors](https://www.npmjs.com/package/cors)
- [Winston](https://www.npmjs.com/package/winston)

### Desafio do Módulo

## Módulo 03

### Aula 01 - Ambiente de Desenvolvimento

Plugins para o VSCode;

- [Cmder]()
- [Yarn]()
- [ES7 React/Redux/GraphQL/React-Native snippets](https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets)

Comando **npx**: Utilizado pelo React para o "creat at app", faz download e instalação de pacotes que são necessãrios e depois remove esse pacote, não for mais utilizado. Diferente do npm.

Comando **yarn**: Alternativa do NPM, padrão do React, promete ser mais rápido que o NPM.

Instalando e configurando o Cmder no Windows.

### Aula 02 - Introdução ao React

*A JavaScript **library** for bulding user interfaces*

O React não se autointitula como **framework** e sim uma biblioteca front-end. Como uma parte que ajuda a manipular as interfaces de usuário.

React é:

- Declarativo:
  - Componentes reativos com JSX.
  - **Mais foco** no **estado** do app e **regras de negócio**
  - **Menos foco** em manipulação do **DOM manual**
  - Manipulação do DOM performática (Virtual DOM)
- Baseado em componentes:
  - Alto grau de **reutilização de código**
- Manipulação performática do DOM
- A manipulação do DOM é considerada uma operação **cara (lenta)**
- O React só modifica o DOM nos locais que foram realmente alterados
- Esse processo é mais conhecido com **Reconciliation** (algoritmo).

Comandos inicais:

- Criar um projeto React:

  > npx create-react-app test-app

- Criar um projeto React definindo as versão:

  > npx create-react-app --scripts-version 3.4.1 test-app

- Iniciar o servidor de desenvolvimento:

  > yarn start

### Aula 03 - Desafio Guiado 1

{ ... }

### Aula 04 - Classes com JavaScript

O React utiliza Class Components.

```javascript
// File script.js

class Animal {
  // Pode ou não receber parâmetros
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} falando...`);
  }
}

class Dog extends Animal {
  constructor(name, type) {
    super(name);

    this.type = type;
  }

  // Sobreescrevendo método
  speak() {
    console.log(`${this.name} (${this.type}) latindo...`);
  }
}

class Cat extends Animal {
  constructor(name, type) {
    super(name);

    this.type = type;
  }

  // Sobreescrevendo método
  speak() {
    console.log(`${this.name} (${this.type}) latindo...`);
  }
}

// Intanciando a classe para um novo Objeto
const animal = new Animal('Totó');
animal.speak();

const dog = new Animal('Jack', 'Poodle');
dog.speak();

const cat = new Animal('Han Solo', 'Frajola');
cat.speak();
```

### Aula 05 - Class Components – Parte 1

Algumas observações:

- Ao criar um componente, utilizar o atalho "**rcc** + **tab**", do plugin ES7 no VSCode.
- **Class Components**, uma das formas de se criar components com React.
- Toda **Class Components** herda da React.Component.
- Se utilizar **construtor**, deve-se informar o método **super();** na primeira instrução.
- **Class Components** permitem a utilização de **atributos** e **métodos** assim como qualquer classe **JavaScript**.
- O principal método de um **Class Component** é o **render()**.
- No React, é utilizado **JSX** para a confecção da **interface gráfica**.
- Para interpolar expressões JavaScript, utilize chaves **{}**.
- É utilizado o **CSS Modules** nos projetos para utilizar o CSS nos componentes, porém existem outras formas.

### Aula 06 - Class Components – Parte 2

Algumas observações:

- Para trabalhar com estado, defina valores em **this.state**.
- O estado deve ser alterado com **this.steState()**.
- A comunicação entre componentes é feita com **props**.
- O React implementa a estratégia de **one-way data flow (de cima para baixo)**.
- Utilize a **prop onClick** para "**escutar**" o **clique** de botões com React.
- Uma boa prática em **eventos** é utilizar **somente a referência** do método. Na **implementação do método**, utilize **arrow functions**.

### Aula 07 - Ciclo de vida de Class Components

Algumas observações:

- **componentDidMount**, executado **após** o primeiro render() e útil para requisições HTTP, por exemplo.
- **componentDidUpdate**, executado **após** toda invocação de render() e útil para aplicação de "efeitos colaterais".
- **componentWillUnmount**, executado **antes** do componente "morrer" e útil para finalização de objetos, como por exemplo **clearInterval**.
- Para mais informações sobre os ciclos de vida de **Class Components** no React, acesse este [link](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram).

### Aula 08 - Desafio Guiado 2

Algumas observações:

- Para monitorar inputs com React, é importante definir os atributos **value** (não usar **null** e **undefined**, usar **''**) e **onChange**.
- Funções simples, comuns a diversos componentes, podem se situar em módulos isolados (**helpers**). Assim, são mais facilmente reaproveitados.

### Trabalho Prático

Exemplo do efeito de barras: <https://codesandbox.io/s/react-barras-007z5>

### Aula 09 - Functional Components

Algumas observações:

- A **escrita** de **Functional Components** é mais **simples** que a de **Class Components**.
- Em **Functional Components**, utiliza-se **funções**.
- Em **Functional Components**, não há **state**. Utiliza-se somente **props** e se precisar de state utiliza-se **hooks**.
- **Functional Components** são, em regra, somente leitura.
- As **props** pode ser **desestruturadas** já nos parâmetros da **função**.
- **Functional Components** retornam, em regra, JSX.
- **Não** há o método **render()** em **Functional Components**.
- Não há **ciclo de vida (lifecycle)** em **Functional Components**.
- Não há **this** em **Functional Components**.
- **Functional Components** utilizam **funções internas (closures)**.

### Aula 10 - Desafio Guiado 3

Algumas observações:

- Em **Functional Components**, ao criar um componente utilizar o atalho "**rfc** + **tab**", do plugin ES7 no VSCode.

### Aula 11 - React Hooks

Criado pelo Facebook no fim de 2018, fornece uma escrita ainda mais declarativa. Utiliza **closures** e **array destructuring**. Permite a utilização de **estado** em **Functional Components**.

**React Hooks** não pretende (por enquanto, pelo menos) substituir totalmente as **Class Components**. Os principais Hooks são: **useState** e **useEffect**.

#### O Hook useState

- Visa substituir **this.state** e **this.setState** de **Class Components**.
- Escrita mais declarativa.
- Utiliza array destructuring.
- Sintaxe padrão: `const [variable, setVariable] = useState(0);`
- Na instrução acima, **variable** representa a **variável** de **estado**.
- Na instrução acima, **setVariable** representa a **função atualizadora**.
- As **funções atualizadoras** só atuam na **variável** ao qual **"apontam"**.
- **Não** há mais **marge** de **this.setState**.

#### O Hook useEffect

- Visa substituir **componentDidMount**, **componentDidUpdate** e **componentWillUnmount** de **Class Components**.
- Escrita mais declarativa.
- Com **useEffect**, não há mais o conceito de montagem do componente (**mounting**) e atualização do componente (**updating**).
- **useEffect** tem um **modelo mental diferente** dos métodos de **ciclo de vida** - a idéia de **useEffect** é **sincronizar** todo o DOM conforme os valores de **props** e **state**.
- **useEffect** permite utilizar parâmetros extra, conhecido como array de dependências (dependency array ou, simplesmente, **deps**).
  - Quando **não há** o parâmetro, **useEffect** é **invocado após qualquer inicialização - semelhante** a **componentDidUpdate**.
  - Quando o **parâmetro** é **[]**, **useEffect** é **invocado apenas uma vez - semelhante** a **componentDidMount**.
  - Quando o parâmetro está preenchido com **[state1, state2, etc], useEffect** é invocado **após** a **atualização** de **estado** de **qualquer uma das variáveis**.
- Quando **há retorno na função - useEffect** utiliza o retorno para **eliminar recursos - semelhante** ao **componentWillUnmount**.

Referência de boa prática para o uso de **useEffect** com **async**: <https://www.robinwieruch.de/react-hooks-fetch-data>

### Aula 12 - Desafio Guiado 4

Visto de novidade:

- **new Set()**: Estrutura que simula **conjutos**, e uma característica dos conjuntos, é que os elementos não podem se repetir. O **Set()** verifica isso automaticamente, porém pode não ser 100% confiável.
- Em **SPAs**, é uma boa pratica evitar o **submit** dos **forms**, utilizando o **event.preventDefault()**.

### Aula 13 - Desafio Guiado 4 (Continuação)

{ ... }

### Desafio do Módulo

Exemplo do professor: <https://codesandbox.io/s/react-caixas-kf6mi?file=/src/App.js>

## Módulo 04

### Aula 01 - MongoDB: Instalação, banco de dados e coleções

Tipos de Bancos de Dados

- SQL: Relacional, processamento de transações, concorrência, consistência e baixa latência.
- NoSQL (Not Only SQL): Não relacional, alta performance, alta escalabilidade.

Sempre ficar atento ao Teorema de CAP.

Sobre o MongoDB:

- Escrito em C++.
- Alta Disponibilidade.
- Alta escalabilidade.
- Não possui schema definido.
- Não é relacional.
- Sua estrutura básica:
  - Banco de dados.
  - Coleções, ao invés de Tabelas.
  - Documentos, ao invés de Linhas.
  - Campos, ao invés de Colunas.

O MongoDB armazena os dados em formatdo de **JSON**, mas internamente é convertido para binário, chamado de **BSON**. Ex:

```json
{
  titulo: "Curso de Bootcamp",
  autor: "Bruno Teixeira",
  ano: 2019
  categoria: ["Romance", "Biografia"]
}
```

#### Instalação no Windows

Acesse o site do MongoDB: <https://www.mongodb.com/>. Escolha a opção gratuita **Commynity Serve** para download.

Na instalação:

- Escolha entre as opções *Complete* e *Custom*;
- Decida entre criar um usuário ou usuário de rede (padrão);
- Verificar se a opção de instalação do *MongoDB Compass* está marcada, caso necessite da instalação;
- Configurar o MongoDB nas *Variáveis de Ambeinte*:
  - Pegar o caminho da pata */bin* e inserir no Path do Usuário:
  
    `C:\Program Files\MongoDB\Server\4.4\bin`
  
  - Para conferir se deu certo, abra o terminal e digite:

    > mongo --version

#### Principais Comandos

Inicializar o servidor do MongoDB:

> mongod

Definir o local que será armazenado a base dados:

> mongod --dbpath "CAMINHO"

- Também usado para iniciar o bando de dados já criado.

Deixando executando o servidor, abra outro terminal e acesse o servidor com o comando:

> mongo -host localhost:27017

- A porta pode variar.

Lista dos principais comandos do MongoDB no Banco de Dados:

> db.help()

Visualizar todas as bases existentes no servidor local:

> show dbs

Para ver qual base você está no momento:

> db

Para Criar/Acessar uma base de dados:

> use grades

- Quando executado, ele já muda para o banco, ou seja, qualquer alteração vai ocorrer no banco de dados criado ou acessado.

Porém o MongoDB só cria essa base depois que é inserido uma coleção e um documento na base. Exemplo para iserir um documento:

> db.student.insert({ "name": "Bruce" })

- Agora é possível verificar a base a criada:

  > show dbs

  ou

  > db

Excluir uma base de dados:

- Mudar para a base desejada:

  > use grades

- Exclusão;

  > db.dropDatabase()

- Se rodar o comando "db", ainda irá mostrar a base, mas porque ela está em cash. Para verificar realmente a exclusão, use "show dbs".

Comando para criar uma Coleção (**Collection**):

> db.createCollection("NOME_DA_COLEÇÃO", {}) // db.createCollection("student", {})

- Também é possivel passar parâmetros opcionais. Como por exemplo, limitar que a coleção terá uma quatidade limite a quantidade de documentos ou em MBytes (espaço). Se limitado o tamanho da coleção, quando chegar ao limite de documentos o MongoDB se encarregar de inserir os novos registros e excluir os mais antigos (muito utilizado em coleções de log).

Verificar as coleções que a base possui:

> show collections

Outra forma de criar coleção é inserindo um documento. Se a coleção para o documento não existir, o MongoDB criará automaticamente.

> db.stutends.insert({ "name": "Bruce" }) // db.NOME_DA_COLEÇÃO

Excluir coleção da base de dads:

> db.stutends.drop()

Criar uma coleção *capped*, muito utilizada para logs (obrigatóriamente é preciso passar um tamanho):

> db.createCollection("log", {capped: true, size: 1024, max: 10})

### Aula 02 - MongoDB: Inserir Documentos (Create)

Inserir apenas **um** objeto na Coleção:

> db.COLLECTION.insertOne({ name: "Maria dos Anjos" }); // db.student.insertOne({name: "Maria dos Anjos"});

Inserir **multiplos** documentos na Coleção:

```mongodb
db.student.insertMany([
  { name: "Marco Antônio", subject: "Matematica", type: "Trabalho Prático", value: 15.4 },
  { name: "Ana Maria Silva", subject: "Português", type: "Prova Final", value: 23.8 }
]);

/**
db.COLLECTION.insertMany([{...}, {...}, ...]);
**/
```

Inserir **um** ou **mais** documentos de uma só vez:

```mongodb
// 1 documento
db.student.insert({ name: "Pedro Augusto", subject: "História"});

// 1 ou Mais documentos
db.student.insert([
  { name: "Pedro Augusto", subject: "História", type: "Trabalho Prático", value: 17.5 },
  { name: "Claudia Romualdo", subject: "Quimica", type: "Prova Final", value: 28.5 },
]);
```

O **insertOne** e o **insertMany** retornam o *ObjectId* do objeto/documento inserido no seu *response*. Já o **insert** trás quantos registros foram afetados na inserção do objeto/documento (*WriteResult*) ou trás o *BulkWriteResult*.

### Aula 03 - MongoDB: Consultar Documentos (Retrieve)

Trazer toda a estrutura de uma coleção:

> db.COLLECTION.find(); // db.student.find();

Definir quais dados trazer de uma coleção:

> db.COLLECTION.find(query, projection); // db.student.find({}, {_id: 0, name: 1, value: 1});

- **query**: Quais documentos
- **projection**: Quais campos trazer dos documentos
  - Atribuindo um campo com **0** não retornará o campo. Atribuir o campo com **1**, retornará o campo.

É possível limitar a quantidade de registros para trazer com **limit()** (utiliza a ordenação normal do documentos na base). Exemplo:

> db.COLLECTION.find(query, projection).limit(3); // db.student.find({}, {_id: 0, name: 1, value: 1}).limit(3);

Também é possível pular alguns documentos na consulta com o **skip()**. Exemplo:

> db.COLLECTION.find(query, projection).limit(3).skip(1); // db.student.find({}, {_id: 0, name: 1, value: 1}).limit(3).skip(1);

Para ordenar os resultados que retornam, é usado o comando **sort()**. Exemplo:

> db.COLLECTION.find(query, projection).sort({ propriedade: valor }); // db.student.find({}, {_id: 0, name: 1, value: 1}).sort({ name: 1 });

- **1**: Ordem Crescente
- **-1**: Ordem Decrescente

Trazer de uma forma mais organizada (JSON) os campos da base:

> db.COLLECTION.find(query, projection).pretty(); // db.student.find({}, {_id: 0, name: 1, value: 1}).pretty();

- Ou:

  > db.COLLECTION.find().pretty(); // db.student.find().pretty();

Trazer o primeiro registro. Se não definir nada, ele irá trazer o primeiro registro da ordenação natural.

> db.COLLECTION.findOne(query, projection); // db.student.findOne();

Utilizando **querys**:

> db.COLLECTION.find({ propriedade: valor }, { proriedade: valor }).pretty(); // db.student.find({ subject: "Quimica" }, { _id: 0 }).pretty();

- Com Opeadores Lógicos:

  - **$and**: Retorna todos os documentos que atendem aos critérios definidos para o comando.

    > db.student.find({ $and:[{subject: "Quimica"}, {type: "Prova Final"}] }, { _id: 0 }).pretty();

  - **$not**: Negar o critério da query.

  - **$nor**: Retorna todos os documentos que não atendem ao(s) critério(s).

    > db.student.find({ $nor:[{subject: "Quimica"}, {type: "Prova Final"}] }, { _id: 0 }).pretty();

  - **$or**: Rertorna os dados para se um ou outro dos critérios forem verdadeiros.

    > db.student.find({ $or:[{subject: "Quimica"}, {subject: "Matematica"}] }, { _id: 0 }).pretty();

- Com Opeadores de Comparação:

  - **$eq**: "Igual".

    > //db.student.find({ value: {$eq: 20} }, { _id: 0 }).pretty();

  - **$gt**: "Maior quê".

    > db.student.find({ value: {$gt: 20} }, { _id: 0 }).pretty();

  - **$gte**: "Maior quê ou igual".

    > //db.student.find({ value: {$gt: 20} }, { _id: 0 }).pretty();

  - **$in**: "Dentro dê".

    > db.student.find({ subject: {$in: ["Quimica", "Matematica"]} }, { _id: 0 }).pretty();

  - **$lt**: "Menor quê".

    > //db.student.find({ value: {$gt: 20} }, { _id: 0 }).pretty();

  - **$lte**: "Menor quê ou igual".

    > //db.student.find({ value: {$gt: 20} }, { _id: 0 }).pretty();

  - **$ne**: "Não é igual a quê".

    > //db.student.find({ value: {$gt: 20} }, { _id: 0 }).pretty();

  - **$nin**: "Não pertence".

    > //db.student.find({ value: {$gt: 20} }, { _id: 0 }).pretty();

### Aula 04 - CRUD no MongoDB (Update)

O **updateOne** é utilizado para atualizar um registro na base, se existir dois iguais, ele irá atualizar a primeira ocorrência encontrada.

> db.COLLECTION.updateOne(query, update, options); // db.student.updateOne({name: "Ana Maria Silva", subject: "Português"}, {$set: {type: "Trabalho Prático"}});

- Com operado **$inc**. Incrementa um valor, a partir de um valor já existente no campo.

  > db.student.updateOne({name: "Pedro Augusto", subject: "História"}, {$inc: {value: 10}});

O comando **updateMany** é utilizado para atualizar vários registros, a partir de condições:

> db.COLLECTION.updateMany(query, update, options); // db.student.updateMany({subject: "Matematica", type: "Trabalho Prático"}, {$inc: {value: 2}});

- Inserir um novo campo para todos os documentos da base:

  > db.COLLECTION.updateMany({}, update, options); // db.student.updateMany({}, {$currentDate: {lastModified: true, timestamp: {$type: "timestamp"} }}); // $$NOW: Pegar a hora corrente. $$CLUSTER_TIME: hora em formato timestamp

- Remover um campo de um documento:

  > db.COLLECTION.updateMany({}, update, {$unset: {propriedade: 1}); // db.student.updateMany({}, {$unset: {timestamp: 1}});

Substituir todo o documento por um novo:

> db.COLLECTION.replaceOne(query, update, options); // db.student.replaceOne({_id: ObjectId("5f45b99c2b7505ef7acd20ac")}, {name: "Lucas Pereira", subject: "Fisica", type: "Prova Final", value: 15.4, lastModified: "$$NOW"});

### Aula 05 - MongoDB: Exclusão Documentos (Delete)

Deletar apenas **um** documento da coleção. Caso exista outro documento igual, ele irá excluir a primeira ocorrência.

> db.COLLECTION.deleteOne(query (filter)); // db.student.deleteOne({ _id: ObjectId("5f45bd7d2b7505ef7acd20b1") });

Deletar **mais** de um documento da coleção, com base na query (filtro).

> db.COLLECTION.deleteMany(query (filter)); // db.student.deleteMany({ subject: "Fisica" });

### Aula 06 - MongoDB: Comandos em Massa (BulkWrite)

> db.COLLECTION.bulkWrite(ARRAY_DE_COMANDOS, options);

```mongdb
db.student.bulkWrite([
  {
    insertOne: {
      "document": {
        name: "Thiago Peixoto",
        subject: "Fisica",
        type: "Prova Final",
        value: 16,
        timestamp: new Date()
      }
    }
  },
  {
    insertOne: {
      "document": {
        name: "Patricia Rafaela",
        subject: "Portugues",
        type: "Trabalho Prático",
        value: 21.3,
        timestamp: new Date()
      }
    }
  },
  {
    updateOne: {
      "filter": {
        name: "Marco Antônio"
      },
      "update": {
        $set: {
          subject: "Historia"
        }
      }
    }
  },
  {
    deleteOne: {
      "filter": {
        name: "Pedro Augusto",
        subject: "História",
        type: "Trabalho Prático"
      }
    }
  },
  {
    replaceOne: {
      "filter": {
        _id: ObjectId("5f45bbe12b7505ef7acd20ae")
      },
      "replacement": {
        name: "Tais Bernardes",
        subject: "Fisica",
        type: "Trabalho Prático",
        value: 12,
        lastModified: new Date()
      }
    }
  }
]);
```

### Aula 07 - MongoDB: índices, modelagens e agregações

**Índices** são estruturas de dados especiais que armazenam informações de **um ou vários** campos com uma determinada **ordenação**. O **índice** pode **facilitar e melhor o desempenho** de uma busca por documentos na coleção, ou seja, se por exemplo se tivermos uma coleção com milhares de documentos e já tivermos um índice ordenados de uma forma específica, o desempenho na busca por esta ordenação será melhor.

Porém, deve-se tomar cuidado na criação de muitos índices, pois poderá piorar o desempenho nas operações de inserção, atualização e etc. Já que o MongoDB precisará atualizar esses índices.

Consultar todos os índices da coleção:

> db.COLLECTION.getIndexes(); // db.student.getIndexes();

Criar um índice:

> db.COLLECTION.createIndex({ campo: TIPO_DE_OPERACAO }); // db.student.createIndex({ name: -1 }); // Criar o indice name de forma descendente da coleção student

Excluir o index (Por padrão, não é possível excluir o index **id** e se fosse, não é recomendado):

> db.COLLECTION.dropIndex({ NOME_DO_INDEX }); // db.student.dropIndex({ "name_-1" });

- Além do nome do index, é possível excluir pelo nome do campo:

  > db.COLLECTION.dropIndex({ NOME_DO_CAMPO: OPERACAO }); // db.student.dropIndex({ name: -1 });

- Também é possível excluir todos os index de uma vez (exceto o id):

  > db.COLLECTION.dropIndexes(); // db.student.dropIndexes();

**Índex Textuais**, são índex que permitem pesquisar por textos dentro de determinado campo do tipo **stringo**. Exemplo:

> db.COLLECTION.createIndex({ campo: "TIPO" }); // db.livros.dropIndex({ biografia: "text" });

- Para usar o index textual criado:

  > db.COLLECTION.find({ $OPERAÇÃO: {$OPERADOR: "TEXTOS"} }); // db.livros.find({ $text: {$search: "escritora jornalista"} }, { _id: 1 });

- Dentro do deste **find**, é possível ver a precisão da busca. Por exemplo: "Quais documentos tem maior quantidade de palavras (match de palavras)":

  > db.COLLECTION.find({ $OPERAÇÃO: {$OPERADOR: "TEXTOS"} }); // db.livros.find({ $text: {$search: "escritora jornalista"} }, { _id: 1, score: {$meta: "textScore"} }).sort({ score: {$meta: "textScore"} });

Tipos de Relacionamentos

Os tipos de relacionamentos, nos ajudam a saber qual a estratégia de modelagem no MongoDB.

- **Um para Um:** Ex: Um veículo tem uma única placa.
- **Um para Muitos:** Ex: Uma cidade pode ter vários CEPs.
- **Muitos para Muitos:** Ex: Um aluno pode ter várias e uma aula pode ter vários alunos.

Tipos de Modelagem no MongoDB

Referências (ou normalizados)

Onde podemos referenciar documentos de uma coleção em outras pelo seu ID, semelhante ao modelo relacional de banco de dados.

Documentos embutidos (ou não-normalizados)

Onde teremos todas as referências englobadas dentro de um único documento, ou seja, internalizaremos a relação dentro de um documento. Essa relação é vista como sub-documento, pois os dados são embutidos em arrays ou campos do documento.

Agregação no MongoDB

Agregação é quando se agrupa documentos e é eplicado um determinado cálculo em algum valor.

Comando para fazer uma agregação no MongoDB:

- **$project:** Quais campos trazer na consulta.
- **$match:** "Filter", agregue todos os documentos que contenham esses valores.
- **$group:** Agrupar todos os campos trazidos, trazer um totalizador, por exemplo, somando um campo específico. Existem outros operadores matemáticos..
- **$sort:** Ordenar os campos trazidos. Ex: { campo1: 1, campo2: -1 }
- **$skip:** Pular uma determinada quantia de registros.
- **$limit:** Limitar a quantidade de registros para trazer.

```mongodb
db.COLLECTION.aggregate([
  {
    $project: {}
  },
  {
    $match: { campo: "X" }
  },
  {
    $group: {
      _id: "$campo",
      total: {
        $sum: "$campo"
      }
    }
  },
  {
    $sort: {}
  },
  {
    $skip: N
  },
  {
    $limit: N
  }
]);
```

- Exemplo:

  ```mongodb
  db.student.aggregate([
    {
      $match: { subject: "Historia" }
    },
    {
      $group: {
        _id: {
          subject: "$subject",
          type: "$type"
        },
        total: {
          $sum: "$value"
        }
      }
    },
    {
      $sort: { _id: 1 }
    }
  ]);
  ```

Comandos auxiliares de agregação

Contar quantidade de documentos através de um "filtr/query".

> db.COLLECTION.count(query); // db.student.count({ subject: "Matematica" });

- Outro exemplo:

  > db.student.count({ subject: "Matematica", value: { $gt: 10 } });

Semelhante ao **count**, a diferença é que possui maior precisão.

> db.COLLECTION.countDocuments(query); // db.student.countDocuments({ subject: "Matematica" });

O comando **distinct**, encontra os valores distintos para um campo especificado em uma única coleção ou visualização e retorna os resultados em uma matriz.

> db.COLLECTION.distinct(campo, query); // db.student.distinct("subject", {});

### Aula 08 - MongoDB Atlas

MongoDB Atlas

É uma plataforma autogerenciável, possuindo rotinas de monitoramente, dimensionamento, alertas e provisionamento da base de dados. Também possui recursos como backup, recuperação de dados e talvez o mais importante, a escalabilidade, ou seja, o dimensionamento e provisonamento da base dados, a medida que vai crescendo.

Existem três tipos serviços:

- Sandbox: Serviço gratuito para hospedagem com bancos de dados de até 500MB.
- Shared: Serviço para armazenar base dados com limite de 8GB
- Dedicated: Serviço para armazenar base dados, possuindo uma forma de armazenamento diferente das demais. Com **as a Service** (paga pelo que usa), limite de conexões, transações por segundo e etc.

### Aula 09 - Mongoose

Mongoose é um módulo do NodeJS para possibilitar a conexão com o MongoDB. Fornecendo solução baseada em schemas para modelar os dados da aplicação.

### Aula 10 - API CRUD com Mongloose

### Trabalho Prático

### Aula 11 - Git (Parte 1)

### Aula 12 - Git (Parte 2)

### Aula 13 - Heroku

### Desafio do Módulo

<!-- https://github.com/brunoaugustoteixeira/Aula2_4 -->
<!-- https://github.com/ghosh/awesome-podcasts/blob/master/podcasts.json -->